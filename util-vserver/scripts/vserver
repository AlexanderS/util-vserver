#! /bin/bash
# $Id$

# Copyright (C) 2003 Enrico Scholz <enrico.scholz@informatik.tu-chemnitz.de>
#  
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#  
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#  
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# set -e

: ${UTIL_VSERVER_VARS:=/usr/lib/util-vserver/util-vserver-vars}
test -e "$UTIL_VSERVER_VARS" || {
    echo "Can not find util-vserver installation; aborting..."
    exit 1
}
. "$UTIL_VSERVER_VARS"
. "$_LIB_FUNCTIONS"

### Some local functions

function showHelp()
{
    echo \
$"Usage: $(basename $0) [-s|--sync] [-v|--verbose]
             [--] <vserver> <command> <args>*

<vserver> is the name of a vserver.

Possible commands are:
    start [--nodeps] <start-vservers-opts>*
                ... starts the specified vserver
    stop [--nodeps] <start-vservers-opts>*
                ... stops the specified vserver
    restart     ... restarts the specified vserver; this is the subsequent
                    execution of a synchronized 'stop' and a 'start'
    condrestart ... restarts the vserver when it is running already
    suexec <user> <shell-command> <args*>
                ... executes a command as the specified user in the vserver
    exec <shell-command> <args*>
                ... executes a command as root in the vserver
    enter       ... executes the configured shell in the vserver
    chkconfig <chkconfig-options*>
                ... modifies the init-system; currently, only Red Hat's
		    chkconfig is supported
    running     ... succeeds iff the vserver is running
    status      ... gives out some human readable status information about
                    the vserver, and succeeds iff the vserver is running

    build <buildopts>*
                ... builds a new vserver from scratch

    unify [-R]
		... (de)unify vserver
		
    pkg install <pkg>
		... installs package(s) in the vserver
		
    apt-get,apt-config,apt-cache <apt-opts>*
		... execute the apt-* command for the given vserver
    rpm <rpm-opts>*
		... execute the rpm command for the given vserver

    pkgmgmt externalize|internalize [-y]
		... externalize or internalize the package-management for the
		    given vserver. 'Externalize' means that package metadata
		    and management tools (apt-get,rpm) are living in the host,
		    while 'internalize' means that data and programs from the
		    vserver will be used.

    unify <vunify-opts>*
                ... unify the vserver with its reference vserver(s).
		    

Please report bugs to $PACKAGE_BUGREPORT"
    exit 0
}

function showVersion()
{
    echo \
$"vserver $PACKAGE_VERSION -- manages the state of vservers
This program is part of $PACKAGE_STRING

Copyright (C) 2003 Enrico Scholz
This program is free software; you may redistribute it under the terms of
the GNU General Public License.  This program has absolutely no warranty."
    exit 0
}


### main starts here

set +e

tmp=$(getopt -o +sv --long help,version,sync,verbose -n "$0" -- "$@") || exit 1
eval set -- "$tmp"

OPTION_FORCE_SYNC=
OPTION_VERBOSE=

while true; do
    case "$1" in
	--help)    	showHelp $0 ;;
	--version) 	showVersion ;;
	-v|--verbose)	OPTION_VERBOSE=1;    shift;;
	-s|--sync) 	OPTION_FORCE_SYNC=1; shift;;
	--)	   	shift; break;;
	*)	   	echo $"vserver: internal error; arg=='$1'"; exit 1;;
    esac
done


vserver=$1
cmd=$2

test "$cmd" != build || { shift 2; exec "$_VSERVER_BUILD" -n "$vserver" "$@"; }


allow_legacy=

case "$vserver" in
    ./*) VSERVER_DIR=`pwd`/$vserver;;
    /*)  VSERVER_DIR=$vserver;;
    *)	 VSERVER_DIR=$CONFDIR/$vserver
	 allow_legacy=1
	 ;;
esac

if test "$allow_legacy"; then
    do_legacy=
    test ! -e "$VSERVER_DIR/legacy" || do_legacy=1
    test -d "$VSERVER_DIR" -o ! -e "$CONFDIR/$vserver.conf" || do_legacy=1

    test -z "$do_legacy" || {
	echo $"WARNING: can not find configuration, assuming legacy method"
	exec "$_VSERVER_LEGACY" "$@"
    }
fi

test -d "$VSERVER_DIR" || {
    echo "Can not find vserver-setup"
    exit 1
}

if test -e "$VSERVER_DIR"/name; then
    read VSERVER_NAME <"$VSERVER_DIR"/name
else
    VSERVER_NAME=$(basename "$VSERVER_DIR")
fi

. $PKGLIBDIR/vserver.functions
case "$2" in
    start|stop|suexec)
	shift 2
	. $PKGLIBDIR/vserver.$cmd
	;;
    restart)
	"$0" --sync "$1" stop
	exec "$0" "$1" start
	;;
    condrestart)
	test ! isVserverRunning "$VSERVER_DIR" || exec "$0" "$1" restart
	;;
    exec)
	shift 2
	exec "$0" "$vserver" suexec root "$@"
	;;
    chkconfig)
	shift 2
	exec "$0" "$vserver" suexec root chkconfig "$@"
	;;
    enter)
	getEnterShell "$VSERVER_DIR"
	exec "$0" "$1" suexec root "${ENTER_SHELL[@]}"
	;;
    running)
	isVserverRunning "$VSERVER_DIR"
	;;

    unify)
	shift 2
	exec $_VUNIFY "$@" "$vserver"
	;;
	
    pkg)
	shift 2
	exec $_VPKG "$vserver" "$@"
	;;

    apt-get|apt-config|apt-cache)
	export _APT_GET=$2
	shift 2
	exec $_VAPT_GET -- "$@"
	;;
    rpm)
	exec $_VRPM -- "$@"
	;;
	
    status)
	if getVserverStatus "$VSERVER_DIR" ctx procnum; then
	    echo $"Vserver '$1' is running at context '$ctx'"

	    if test "$2" = status; then
		echo    $"Number of processes:" $procnum
		echo -n $"Uptime:              "
		"$_FILETIME" "$VSERVER_DIR/run"
	    fi
	    exit 0
	else
	    echo $"Vserver '$1' is not running"
	    exit 1
	fi
	;;
    *)
	echo $"Usage: $0 {start|stop|suexec|restart|condrestart|exec|enter|chkconfig|running|status}"
	exit 2
	;;
esac
