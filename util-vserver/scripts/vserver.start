# $Id$  --*- sh -*--

# Copyright (C) 2003 Enrico Scholz <enrico.scholz@informatik.tu-chemnitz.de>
#  
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#  
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#  
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

lock "$LOCKDIR"/vserver."$(echo "$VSERVER_DIR" | tr -dc a-zA-Z0-9)".startup

if isVserverRunning "$VSERVER_DIR"; then
    echo $"vserver '$VSERVER_NAME' already running; aborting..." >&2
    exit 1
fi

function cleanup()
{
    set +e

    test -z "$startsync_pipe"  || rm -f "$startsync_pipe"
    test -z "$is_started"      || { unlock; return 0; }

    if test "$is_configured" -a -z "$is_executed"; then
	warning $"
An error occured while executing the vserver startup sequence; when
there are no other messages, it is very likely that the init-script
(${INITCMD_START[@]}) failed.

Common causes are:
* /etc/rc.d/rc on Fedora Core 1 and RH9 fails always; the 'apt-rpm' build
  method knows how to deal with this, but on existing installations,
  appending 'true' to this file will help."
    fi

    if test "$is_executed"; then
	warning $"
An error occured after executing the vserver startup sequence. This
means that some processes may exist in the created context and the
manual execution of

  $_VSERVER '$VSERVER_DIR' stop

is recommended to fix this."
    else
	warning $"

Failed to start vserver '$VSERVER_NAME'"
    fi

    test    "$OPTION_DEBUG"    || exec 2>/dev/null >/dev/null
    test -z "$is_mounted"      || umountVserver     "$VSERVER_DIR" || :
    test -z "$have_interfaces" || disableInterfaces "$VSERVER_DIR" || :

    unlock || :
}

is_configured=
is_executed=
is_started=
is_mounted=
is_vshelper_init=
have_interfaces=
startsync_pipe=

set -e
trap "cleanup" EXIT

vshelper.doSanityCheck

generateOptions  "$VSERVER_DIR"
execScriptlets   "$VSERVER_DIR" "$VSERVER_NAME" prepre-start
enableInterfaces "$VSERVER_DIR" && have_interfaces=1

mountVserver "$VSERVER_DIR"     && is_mounted=1
prepareInit  "$VSERVER_DIR"

pushd "$VSERVER_DIR"/vdir/ >/dev/null
execScriptlets   "$VSERVER_DIR" "$VSERVER_NAME" pre-start
popd >/dev/null

test -z "$OPTION_DEFAULTTTY" || setDefaultTTY "$VSERVER_DIR"

pushd "$VSERVER_DIR"/vdir/ >/dev/null
is_configured=1
if $_VSERVER_INFO - FEATURE migrate; then
    $_CHBIND     "${CHBIND_OPTS[@]}" -- \
    $_VCONTEXT   --create "${OPTS_VCONTEXT_CREATE[@]}" -- \
    ${USE_VNAMESPACE:+$_VNAMESPACE --set -- } \
    $_VLIMIT     --dir "$VSERVER_DIR"/rlimits --missingok -- \
    $_VSCHED     --xid self "${OPTS_VSCHED[@]}" -- \
    $_VUNAME     --xid self --dir "$VSERVER_DIR"/uts     --missingok -- \
    "${VSERVER_EXTRA_CMDS[@]}" \
    $_VUNAME     --xid self --set -t context="$VSERVER_DIR" -- \
    $_VATTRIBUTE --set "${OPTS_VATTRIBUTE[@]}" -- \
    $_SAVE_CTXINFO "$VSERVER_DIR" \
    $_CLEARENV \
    $_VCONTEXT   --migrate-self --endsetup --chroot $SILENT_OPT "${OPTS_VCONTEXT_MIGRATE[@]}" -- \
    "${INITCMD_START[@]}"
else
    if test "$_IS_FAKEINIT"; then
	startsync_pipe=$(mktemp /tmp/vserver-start.XXXXXX)
	rm -f "$startsync_pipe"
	mkfifo -m600 "$startsync_pipe"	## safe, since mkfifo does not follow symlinks
    fi
    
    ${NICE_CMD[@]} \
    $_CHBIND           "${CHBIND_OPTS[@]}" \
    $_EXEC_ULIMIT      "$VSERVER_DIR/ulimits" \
    $_CHCONTEXT_COMPAT "${CHCONTEXT_OPTS[@]}" "${CHCONTEXT_INIT_OPTS[@]}" \
    $_SAVE_CTXINFO     "$VSERVER_DIR" \
    $_CLEARENV \
    $_CHAINECHO "${_IS_FAKEINIT:+$startsync_pipe}" "" \
    $_CAPCHROOT        "${CAPCHROOT_OPTS[@]}" . \
    "${INITCMD_START[@]}"

    ## the additional synchronization step is needed since vshelper.doInit
    ## below might be executed before needed context information were
    ## saved by $_SAVE_CTXINFO
    ${_IS_FAKEINIT:+cat "$startsync_pipe"} >/dev/null
fi
is_executed=1

"${INITCMD_START_SYNC[@]}"
popd >/dev/null

pushd "$VSERVER_DIR"/vdir/ >/dev/null
execScriptlets   "$VSERVER_DIR" "$VSERVER_NAME" post-start
popd >/dev/null

is_vshelper_init=1
! vshelper.isEnabled "" "$VSERVER_DIR" || vshelper.doInit "$VSERVER_DIR"

is_started=1
